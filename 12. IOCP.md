# 12. IOCP

<pre>
IOCP 개요
-> Windows I/O 모델 중 최고의 성능
-> 별도의 커널 객체를 통한 구현
    -> IOCP 객체를 생성해서 핸들을 받아온다.
-> 기본적으로 Overlapped I/O CallBack
    -> callback 함수들을 멀티쓰레드로 동시에 실행
-> IOCP 객체 내부 Thread Poll 사용
    -> Thread 생성 파괴 오버헤드 없앰
    -> 적은 수의 thread로 많은 연결을 관리
-> IOCP 객체 내부 Device List 사용
    -> 등록된 소켓에 대한 I/O는 IOCP가 처리

기존 OverLapped I/O를 했었는데, 특별한 커널 객체가 필요하진 않았다.
단지 옵션에 넣어주고 Send, Recv 호출할 때 OverLapped 파라미터를 넣어주고 했는데, 
IOCP는 좀 특별해서 기존의 Send Recv에 파라미터만 추가하는것이 아니라, IOCP 객체 자체가 필요하다.
IOCP 시스템을 관리하는 객체 하나가 필요하다. 
어떻게? 커널에 요청하는 것이다. 커널에게 IOCP 객체를 만들라고 하면 커널이 만들고, 그 핸들을 프로그램에 넘겨준다.
       우린 핸들을 받아서 사용하면 된다. 파일 I/O를 할 때 파일 자체를 프로그램에 끌고오는게 아니라 핸들을 사용하는 것처럼.

IOCP를 사용한 모든 Send Recv는 OverLapped I/O로 동작한다. 안그러면 동작하지 않는다.
OverLapped I/O 콜백 형식으로 동작한다. 윈도우 Event 따로 만들 필요가 없다. 콜백 방식으로 짜면 IOCP로 동작한다.
근데 이 때 콜백함수를 따로 만들지 않는다. IOCP를 통해서 완료를 확인받고 뒷처리를 한다. 그래서 콜백이라고 부르기도 모호하다.
콜백과 이벤트의 중간 방식인데 적어도 절대로 이벤트 방식은 아니다.

* IOCP 특징중 하나가 멀티쓰레드에서 동작하는 것.
  콜백함수들을 멀티쓰레드에서 동시에 동작해서 성능을 높이는 것이 IOCP 성능의 비결이다.

IOCP는 IOCP 객체를 통해 관리되고, 이건 커널 안에서 관리한다.
커널 안에 여러 자료구조가 있는데 Device List라는 자료구조가 있다. 거기에 소켓들을 등록해서 처리한다.
게임서버가 소켓이 수십개 수백개 수천개 동시에 처리하는데 IOCP 객체는 수천개가 필요한가?
-> 아니다. 1개에서 모든 것을 관리한다. IOCP 객체는 여러 소켓을 관리하는 자료구조, 컨테이너가 필요하고 이걸 Device List라고 부른다.
   소켓을 IOCP에 등록하고, 그럼 Device List에 등록한다. 우리가 그걸 볼 수도 건드릴 수도 없다.
   
어려운 이유
-> Overlapped I/O로만 동작
    -> Overlapped I/O를 모르면 이해할 수 없다.
-> 비 직관적인 API
    -> 하나의 API를 여러 용도로 사용
        -> 파라미터에 따라 완전히 다르게 동작하는 API
        -> API 이름과 아무 관계도 없는 동작을 하는 경우가 있다.
    -> 뜬금없는 API 파라미터
        -> 하나의 API를 여러 용도로 사용하기 때문이다.
        -> 파라미터로 넘어오는 정보들이 불완전함 -> 편법으로 보완이 필요하다.
        
 * IOCP가 대규모 연결 처리가 가능한 고성능 API인데 사용하기 어렵다는 단점이 있다.
   Overlapped I/O가 왜 성능이 대규모 연결에는 부족한가? 멀티스레드 API가 없기 때문이다.
   멀티쓰레드를 돌리려면 스레드마다 소켓을 따로 돌려야 한다.
   쓰레드마다 Send Recv를 따로 돌려야한다. 그래서 Accpet 받아서 Recv 등록할 때 어느 쓰레드에서 Recv할 것인가 판단하고
   그 쓰레드에 Recv를 넘기는 까다로운 프로그래밍을 해줘야한다.
   쓰레드간의 소켓 작업을 따로 넘기는 프로그래밍을 해야하는데, 그걸 직접 구현하는건 오버헤드가 상당히 크다.
   하지만, IOCP는 그것을 자동으로 해서 성능이 뛰어나다.

ref : https://popcorntree.tistory.com/80?category=813524
</pre>
