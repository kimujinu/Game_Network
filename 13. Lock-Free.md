# 13. LOCK-FREE 알고리즘

<pre>
* Lock-Free 알고리즘을 알아보기 전에, Non-Blocking 알고리즘을 알아야 한다.

Non-Blocking 알고리즘 개요
-> 동기화 기법(lock 등)을 무차별하게 사용하게 된다면 기아현상을 유발할 수 있다.
   사용자가 느끼기에 중요한 Thread가 상대적으로 별로 중요하지 않은 Thread에 밀려서 자원획득을 못하고 있을 가능성이 존재한다.
   프로그래머가 프로그래밍을 잘하면 해결할 수 있는 문제라고 생각할수도 있다.
-> 기아현상만 발생할 수 있는 것뿐만 아니라, 성능적 이슈도 있을 수 있다.
   CRITICAL_SECTION을 사용하는 Mutex 역시 시스템 자원이다.
   Lock을 거는것 하나하나가 시스템 자원요청이라고 생각하면 Lock을 거는 것 자체가 오버헤드이다.
   게다가 자원을 얻을 때까지 나머지 대기 Thread는 Blocking 상태에 빠진다.
   만약, 빈번하게 접근해야 하는 공유자원을 사용하려고 하는데 이동 때마다 Lock, UnLock이 반복된다면
         차라리 싱글쓰레드 서버가 빠른 상황이 연출될 수 도 있다.
-> 위의 상황만을 예로 든다면, 굳이 멀티쓰레드 프로그래밍을 할 이유가 없다.
   하지만, 여전히 컴퓨터는 프로세서 개수를 늘이는 방향으로 진화하고 있으니, 어딘가 누군가 만든 무언가의 방법이 있을 것이다.
   그런것들을 통침 Non-Blocking(공유 자원 관리) 알고리즘이라 한다.
   
Non-Blocking 알고리즘 이란?
-> Non-Blocking 알고리즘에는 등급이 있다.
   가장 이상적인 것은 전체 쓰레드가 공유 자원을 일관적으로 사용하면서도 대기하지 않고 그냥 진행되는 형식의 알고리즘이다.
   이것을 Wait-Free 수준의 알고리즘이라고 한다.
   하지만, Wait-Free를 제대로 구현하려면 많은 제약이 따른다.
   그래서 매우 한정적인 상황에서만 Wait-Free 알고리즘을 적용할 수 있다. 
-> 그렇기 때문에 일반적인 경우에는 Lock-Free 수준의 알고리즘을 사용한다. 

LOCK-Free 알고리즘 이란?
-> MultiThread에서의 동기화 기법(lock 등)을 사용하지 않고 다중 호출에 대하여 최소한 1개의 호출이 완료되는 알고리즘
   즉, 여러개의 Thread에서 동시에 작업이 호출되었을 경우 정해진 시간마다 적어도 한개의 작업이 호출되는 알고리즘
       흔히 사용하는 Mutex를 사용하면 하나도 실행이 안될 수 있다.
       하지만, Lock-Free는 적어도 1개는 무조건 실행이 되고 있어야 한다. (작업이 몇 천만번이라면, 생각보다 큰 차이가 난다.)
       호출이 다른 Thread와 충돌하였을 경우 적어도 하나의 승자가 있어서, 승자는 delay없이 완료된다.
-> Game Server에서는 JobQueue등에서 사용할 수 있다.
-> 원리는 자료구조에 대하여 변경을 수행할 때 다른 Thread가 접근한 경우 작업 시도를 취소하는 것이다.

Lock-Free 알고리즘의 구조
-> Atomic 연산을 통해 Lock-Free를 구현한다. 
-> 시스템(하드웨어 수준)에서 원자성을 보장하는 연산을 atomic 연산이라고 한다.
   Windows에서 Atomic연산들은 보통 Interlocked** 으로 제공된다. 
-> atomic 연산은 실행이 한번에 완료되는 것을 보장하므로, 쓰레드 동기화 문제에서 쉽게 벗어날 수 있다.
-> 여러 atomic 연산이 있는데 그중에 Lock-Free에 가져다 쓰기 가장 좋은 것이 CAS(Compare-and-set/swap, Windows에서 비슷한 함수는 
   InterlockedCompareExchange)이다.
   지금 쓰려고 하는 대상이 현재 쓰레드의 맥락에서 일관적이면, 변경을 가하고 그렇지 않으면 fail로 떠서 대기하지 않고
   바뀐 상태로 쓰레드의 로컬정보를 갱신한뒤 다른 작업을 진행하는 것이다.
-> Non-Blocking I/O와 유사하게 체크해서 성공하면 계획대로 작업을 수행하고, 실패하면 다른작업을 하다가 다시 체크를 하는 구조를 갖게 된다.

Lock-Free 알고리즘을 사용하는 이유
-> 잘못된 MultiThread 사용으로 인한 성능 하락이 없다.
-> lock을 사용하지 않고 DeadLock 이슈를 피하기 위해
-> 다른 Thread의 상태와 상관없이 호출이 완료된다.
-> non blocking 하면서 원장성을 유지해야 하는 경우 사용한다.

Lock-Free에서 사용하는 자료구조
-> Queue : enqueue, dequeue
-> Stack : pop, push
-> BinaryTree : insert, delete, search

Lock-Free 알고리즘의 단점
-> 구현하기가 다소 난해하다.
-> 코드가 복잡해져서 버그를 발견하기가 어렵다.

</pre>
