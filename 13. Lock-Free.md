# 13. LOCK-FREE 알고리즘

<pre>
* Lock-Free 알고리즘을 알아보기 전에, Non-Blocking 알고리즘을 알아야 한다.

Non-Blocking 알고리즘 개요
-> 동기화 기법(lock 등)을 무차별하게 사용하게 된다면 기아현상을 유발할 수 있다.
   사용자가 느끼기에 중요한 Thread가 상대적으로 별로 중요하지 않은 Thread에 밀려서 자원획득을 못하고 있을 가능성이 존재한다.
   프로그래머가 프로그래밍을 잘하면 해결할 수 있는 문제라고 생각할수도 있다.
-> 기아현상만 발생할 수 있는 것뿐만 아니라, 성능적 이슈도 있을 수 있다.
   CRITICAL_SECTION을 사용하는 Mutex 역시 시스템 자원이다.
   Lock을 거는것 하나하나가 시스템 자원요청이라고 생각하면 Lock을 거는 것 자체가 오버헤드이다.
   게다가 자원을 얻을 때까지 나머지 대기 Thread는 Blocking 상태에 빠진다.
   만약, 빈번하게 접근해야 하는 공유자원을 사용하려고 하는데 이동 때마다 Lock, UnLock이 반복된다면
         차라리 싱글쓰레드 서버가 빠른 상황이 연출될 수 도 있다.
-> 위의 상황만을 예로 든다면, 굳이 멀티쓰레드 프로그래밍을 할 이유가 없다.
   하지만, 여전히 컴퓨터는 프로세서 개수를 늘이는 방향으로 진화하고 있으니, 어딘가 누군가 만든 무언가의 방법이 있을 것이다.
   그런것들을 통침 Non-Blocking(공유 자원 관리) 알고리즘이라 한다.
   
Non-Blocking 알고리즘 이란?
-> Non-Blocking 알고리즘에는 등급이 있다.
   가장 이상적인 것은 전체 쓰레드가 공유 자원을 일관적으로 사용하면서도 대기하지 않고 그냥 진행되는 형식의 알고리즘이다.
   이것을 Wait-Free 수준의 알고리즘이라고 한다.
   하지만, Wait-Free를 제대로 구현하려면 많은 제약이 따른다.
   그래서 매우 한정적인 상황에서만 Wait-Free 알고리즘을 적용할 수 있다. 
-> 그렇기 때문에 일반적인 경우에는 Lock-Free 수준의 알고리즘을 사용한다. 

LOCK-Free 알고리즘 이란?
-> MultiThread에서의 동기화 기법(lock, Mutex 등)을 사용하지 않고 다중 호출에 대하여 최소한 1개의 호출이 완료되는 알고리즘
   즉, 여러개의 Thread에서 동시에 작업이 호출되었을 경우 정해진 시간마다 적어도 한개의 작업이 호출되는 알고리즘
       흔히 사용하는 Mutex를 사용하면 하나도 실행이 안될 수 있다.
       하지만, Lock-Free는 적어도 1개는 무조건 실행이 되고 있어야 한다. (작업이 몇 천만번이라면, 생각보다 큰 차이가 난다.)
       호출이 다른 Thread와 충돌하였을 경우 적어도 하나의 승자가 있어서, 승자는 delay없이 완료된다.
-> Game Server에서는 JobQueue등에서 사용할 수 있다.
-> 원리는 자료구조에 대하여 변경을 수행할 때 다른 Thread가 접근한 경우 작업 시도를 취소하는 것이다.

Lock-Free 알고리즘의 구조
-> Atomic 연산을 통해 Lock-Free를 구현한다. 
-> 시스템(하드웨어 수준)에서 원자성을 보장하는 연산을 atomic 연산이라고 한다.
   Windows에서 Atomic연산들은 보통 Interlocked** 으로 제공된다. 
-> atomic 연산은 실행이 한번에 완료되는 것을 보장하므로, 쓰레드 동기화 문제에서 쉽게 벗어날 수 있다.
-> 여러 atomic 연산이 있는데 그중에 Lock-Free에 가져다 쓰기 가장 좋은 것이 CAS(Compare-and-set/swap, Windows에서 비슷한 함수는 
   InterlockedCompareExchange)이다.
   지금 쓰려고 하는 대상이 현재 쓰레드의 맥락에서 일관적이면, 변경을 가하고 그렇지 않으면 fail로 떠서 대기하지 않고
   바뀐 상태로 쓰레드의 로컬정보를 갱신한뒤 다른 작업을 진행하는 것이다.
-> Non-Blocking I/O와 유사하게 체크해서 성공하면 계획대로 작업을 수행하고, 실패하면 다른작업을 하다가 다시 체크를 하는 구조를 갖게 된다.
* CAS연산자 : 변경 대상이 예상한 값과 똑같다면 새로운 값으로 바꿔주는 연산자.
             예상한 값과 다르다면 값을 변경하지 않는다.
             이 모든일이 원자적으로 일어나기 때문에 Thread-safe 한다.
             Lock-Free는 CAS없이 구현할 수 없다.

Lock-Free 알고리즘을 사용하는 이유
-> 잘못된 MultiThread 사용으로 인한 성능 하락이 없다.
-> lock을 사용하지 않고 DeadLock 이슈를 피하기 위해
-> 다른 Thread의 상태와 상관없이 호출이 완료된다.
-> non blocking 하면서 원장성을 유지해야 하는 경우 사용한다.
-> 높은 부하에도 안정적으로 운영이 가능.

Lock-Free에서 사용하는 자료구조
-> Queue : enqueue, dequeue
-> Stack : pop, push
-> BinaryTree : insert, delete, search

Lock-Free 알고리즘의 단점
-> 생산성 : 구현하기가 다소 난해하다.
-> 코드가 복잡해져서 버그를 발견하기가 어렵다.
-> 신뢰성 : 정확성을 증명하는 것은 어렵다.
-> 확장성 : 새로운 메소드를 추가하는 것이 매우 어렵다.
-> 메모리 : 메모리 재사용의 관리가 어렵다. (ABA문제)

ABA문제
-> CAS의 기능적 한계로 발생하는 문제이다.
-> 메모리 재사용으로 인한 문제이기 때문에, C#, Python, Java와 같이 GC가 있는 환경에서는 ABA문제가 발생하지 않는다.

ABA문제 해결방안
-> 순수한 "주소"가 아닌 Bit를 쪼개어 "주소+Stamp"를 사용한다.
    -> Stamp란 CAS연산이 성공한 횟수이다.
       Push, Pop이 발생할 때마다 Stamp 값을 증가시킨다.
       Stamp 값이 달라지므로 메모리가 재사용이 되어도 유니크한 값을 가지게 된다.
    -> Stamp가 최댓값을 넘어가는 경우 ABA문제가 다시 발생할 수 도 있다. (발생할 가능성은 낮음)
        -> 해결법 
            -> Stamp 비트를 넉넉히 잡아 초기화가 덜 발생하도록 한다. 최소 23비트를 강제하고 있따.
            -> Stamp가 0으로 초기화 되면, PushPop을 하기 전에 Thread를 중단시켜 다른 Thread에게 턴을 넘긴다.
-> CAS 대신 LL, SC 명령어 사용
    -> 단순한 값비교가 아닌 다른 쓰레드가 메모리를 변경했는지까지 검사 할 수 있는 명령어이지만,
       일부 CPU (ARM,PowerPC) 에서만 지원되는 명령어 이므로 x86 CPU에서는 사용할 수 없다.
-> Reference Count 사용 (ex) shared_ptr)
    -> Reference Count로 인해 곧바로 메모리를 재사용하지 않는다.
       shared_ptr는 CAS연산자를 사용할 수 없으므로 자체적인 시스템을 만들어야 하는데 GC가 이러한 시스템을 기반으로 한다.

Lock의 잠재적인 문제
-> Priority Inversion(우선순위 역전) : 상대적으로 우선순위가 가장 높은 프로세스인 'A'가 마치 우선순위가 가장 낮은 프로세스처럼 실행되는 현상
    -> 우선순위 역전현상 해결 방식
        -> PIP(Priority Inheritance Protocol) : 같은 공유자원을 사용하려는 우선순위가 더 높은 프로세스가 접근한다면, 임시적으로 해당 프로세스의 우선순위로 바꿔버리는 방식
        -> PCP(Priority Ceiliing Protocol) : 공유자원을 사용하는 프로세스가 실행되어지면, 그 순간부터 우선순위를 매우 높여주는 방식
-> Convoying : MultiThread 구현 시 무분별한 Lock의 사용으로 인해 Thread가 작업 시 다른 Thread는 Lock에 걸린채 대기하는 문제
-> DeadLock, LiveLock : Thread가 상대방만 바라보면 영원히 Job이 진행되지 않는 상태
    -> DeadLock : Thread가 Block 상태로 잠들어버리는 현상
    -> LiveLock : Running 상태인데도 실제로 진행되는 작업은 없다.
</pre>
